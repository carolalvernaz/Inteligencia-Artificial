# -*- coding: utf-8 -*-
"""Perceptron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/149fEY74gEibfpCuv2nnY8ZdG5uTgX-IS
"""

import numpy as np
import matplotlib.pyplot as plt
from itertools import product

class Perceptron:
    def __init__(self, n_inputs, learning_rate=0.5, max_epochs=100):
        self.n_inputs = n_inputs
        self.learning_rate = learning_rate
        self.max_epochs = max_epochs
        self.weights = np.zeros(n_inputs + 1)

    def activation_function(self, u):
        return 1 if u >= 0 else 0

    def predict(self, x):
        x_aug = np.insert(x, 0, 1)
        u = np.dot(self.weights, x_aug)
        return self.activation_function(u)

    def train(self, X, y):
        for epoch in range(self.max_epochs):
            error_occurred = False
            for xi, di in zip(X, y):
                xi_aug = np.insert(xi, 0, 1)
                yi = self.predict(xi)
                error = di - yi
                if error != 0:
                    self.weights += self.learning_rate * error * xi_aug
                    error_occurred = True
            if self.n_inputs == 2:
                self.plot_decision_boundary(X, y, epoch)
            if not error_occurred:
                break

    def plot_decision_boundary(self, X, y, epoch):
        plt.figure()
        for xi, target in zip(X, y):
            if target == 1:
                plt.plot(xi[0], xi[1], 'bo')
            else:
                plt.plot(xi[0], xi[1], 'rx')

        x_vals = np.array(plt.gca().get_xlim())
        if self.weights[2] != 0:
            y_vals = -(self.weights[1] * x_vals + self.weights[0]) / self.weights[2]
            plt.plot(x_vals, y_vals, 'k--')
        plt.title(f"Época {epoch + 1}")
        plt.grid(True)
        plt.show()


def generate_logical_data(n, logic_function):
    X = np.array(list(product([0, 1], repeat=n)))
    if logic_function == 'AND':
        y = np.array([int(np.all(xi)) for xi in X])
    elif logic_function == 'OR':
        y = np.array([int(np.any(xi)) for xi in X])
    else:
        raise ValueError("Função lógica inválida. Use AND ou OR.")
    return X, y


def main():
    logic_function = input("Digite a função lógica (AND ou OR): ").strip().upper()
    n = int(input("Digite o número de entradas booleanas (ex: 2, 3, 10): "))

    X, y = generate_logical_data(n, logic_function)
    perceptron = Perceptron(n_inputs=n)
    perceptron.train(X, y)

    print("\nResultados finais:")
    for xi, di in zip(X, y):
        yi = perceptron.predict(xi)
        print(f"Entrada: {xi}, Esperado: {di}, Previsto: {yi}")


if __name__ == '__main__':
    main()